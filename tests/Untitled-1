{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 75,
   "id": "a13b4c69",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb388f61",
   "metadata": {},
   "source": [
    "## Register Status"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "id": "46f8c36e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def ini_register_status():\n",
    "    register_status = {}\n",
    "\n",
    "    # Registradores inteiros (x0..x31)\n",
    "    for i in range(32):\n",
    "        register_status[f\"x{i}\"] = {\"x\": i, \"x_type\": \"int\", \"writer\": None}\n",
    "\n",
    "    # Registradores de ponto flutuante (f0..f31)\n",
    "    for i in range(32):\n",
    "        register_status[f\"f{i}\"] = {\"f\": i, \"f_type\": \"float\", \"writer\": None}\n",
    "    return register_status\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3ba015fc",
   "metadata": {},
   "source": [
    "## Parser das instruções"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6fca31db",
   "metadata": {},
   "outputs": [],
   "source": [
    "OPCODES = {\n",
    "    'fld': 0,\n",
    "    'fsd': 1,\n",
    "    'fadd': 2,\n",
    "    'fsub': 3,\n",
    "    'fmul': 4,\n",
    "    'fdiv': 5\n",
    "}\n",
    "\n",
    "# Define register prefix constants\n",
    "REG_PREFIXES = {\n",
    "    'x': 'int',\n",
    "    'f': 'float'\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "id": "e2a4bd62",
   "metadata": {},
   "outputs": [],
   "source": [
    "def init_instruction_status(program_name):\n",
    "    instruction_status =[]\n",
    "    with open(program_name, \"r\") as file:\n",
    "        for i, line in enumerate(file):\n",
    "            op = OPCODES[line.split()[0]]\n",
    "            if (op == 0 or op==1):\n",
    "                rd = line.split()[1].replace(\",\", \"\")\n",
    "                rs1 = line.split()[2].split(\"(\")[1].replace(\")\", \"\")\n",
    "                rs2 = None\n",
    "                imm = line.split()[2].split(\"(\")[0]\n",
    "                fu_type = 0\n",
    "            else:\n",
    "                if op == 2 or op == 3: fu_type = 2\n",
    "                elif op == 4: fu_type = 1\n",
    "                elif op == 5: fu_type = 3\n",
    "                rd = line.split()[1].replace(\",\", \"\")\n",
    "                rs1 = line.split()[2].replace(\",\", \"\")\n",
    "                rs2 = line.split()[3].replace(\",\", \"\")\n",
    "                imm = None          \n",
    "            instruction_status.append({ \n",
    "                \"id\": i,\n",
    "                \"inst\": line.replace(\"\\n\", \"\"),\n",
    "                \"opcode\": op,\n",
    "                \"fu_name\": None,\n",
    "                \"fu_type\": fu_type,\n",
    "                \"rd\": rd,\n",
    "                \"rs1\": rs1,\n",
    "                \"rs2\": rs2,\n",
    "                \"imm\": imm,\n",
    "                \"issue\": None,\n",
    "                \"read_operands\": None,\n",
    "                \"execution_complete\": None,\n",
    "                \"write_result\": None,\n",
    "                \"issue\": None, \n",
    "                \"read\": None, \n",
    "                \"exec\": None, \n",
    "                \"write\": None\n",
    "\n",
    "            })\n",
    "    return  instruction_status"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "43f902aa",
   "metadata": {},
   "source": [
    "## Parser das functionals units"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "id": "72e6e1aa",
   "metadata": {},
   "outputs": [],
   "source": [
    "def parser_fus_configs(config_name):\n",
    "    fus_configs = {}\n",
    "    with open(config_name, 'r') as f:\n",
    "        linhas = f.readlines()\n",
    "        for linha in linhas:\n",
    "            partes = linha.strip().split()\n",
    "            fus_configs[partes[0]] = {'qtd': partes[1], 'cycles': partes[2]}\n",
    "    return fus_configs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "id": "34a53361",
   "metadata": {},
   "outputs": [],
   "source": [
    "def init_fus_status(fus_configs):\n",
    "    fus_configs = parser_fus_configs(config_name=\"tests/uf_config1.in\")\n",
    "    fus_status = {}\n",
    "    for uf_type, config in fus_configs.items():\n",
    "        if uf_type == 'int':\n",
    "            op = 0\n",
    "        elif uf_type == 'mult':\n",
    "            op = 1\n",
    "        elif uf_type == 'add':\n",
    "            op = 2\n",
    "        elif uf_type == 'div':\n",
    "            op = 3\n",
    "        for c in range(int(config['qtd'])):\n",
    "            fus_status[f'{uf_type}{c+1}'] = {\n",
    "                'Opcode': op, \n",
    "                'Busy': False, \n",
    "                'Op': None, \n",
    "                'Fi': None,\n",
    "                'Fj': None, \n",
    "                'Fk': None, \n",
    "                'Qj': None, \n",
    "                'Qk': None,\n",
    "                'Rj': False, \n",
    "                'Rk': False, \n",
    "                'Cycles_left': int(config['cycles']), \n",
    "                'Cycles': int(config['cycles'])\n",
    "            }\n",
    "    return fus_status"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f37b3d53",
   "metadata": {},
   "source": [
    "## ISSUE"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1659df50",
   "metadata": {},
   "source": [
    "Verificar se a unidade funcional requerida está livre -- sem hazards estruturais\n",
    "    \n",
    "    Functional unit status -- verificada aqui\n",
    "\n",
    "Verificar se nenhuma outra instrução vai escrever no rd -- sem WAW hazards\n",
    "    \n",
    "    Register Status -- verificado aqui"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a1a051ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "def issue(instr, fus_status, register_status):\n",
    "    opcode_i = instr['opcode']\n",
    "    id_i = instr['id']\n",
    "    rs1_i = instr['rs1']\n",
    "    rs2_i = instr['rs2']\n",
    "    rd_i = instr['rd']\n",
    "    for fu_name, fu in fus_status.items():\n",
    "        # verifica se a unidade funcional corresponde à instrução\n",
    "        # se a unidade funcional não está vazia\n",
    "        # se nenhuma outra FU n está escrevendo no rd\n",
    "        if fu['Opcode'] != opcode_i or fu['Busy'] or register_status[rd_i]['writer'] is not None:\n",
    "            continue\n",
    "        fu['Busy'] = True\n",
    "        fu['Op'] = id_i\n",
    "        fu['Fi'] = rd_i\n",
    "        fu['Fj'] = rs1_i\n",
    "        fu['Fk'] = rs2_i\n",
    "        fu['Qj'] = register_status[rs1_i]['writer'] if rs1_i is not None else None\n",
    "        fu['Qk'] = register_status[rs2_i]['writer'] if rs2_i is not None else None\n",
    "        fu['Rj'] = fu['Qj'] is None\n",
    "        fu['Rk'] = fu['Qk'] is None\n",
    "        register_status[rd_i]['writer'] = fu_name\n",
    "        instr['fu_name'] = fu_name\n",
    "        return True\n",
    "    return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "id": "e806b3bc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def issue(instr, fus_status, register_status):\n",
    "    opcode_i = instr['opcode']\n",
    "    id_i = instr['id']\n",
    "    rs1_i = instr['rs1']\n",
    "    rs2_i = instr['rs2']\n",
    "    rd_i = instr['rd']\n",
    "    fu_type = instr['fu_type']\n",
    "\n",
    "    print(f\"\\n[ISSUE] Tentando emitir instrução {id_i}: {instr['inst']}\")\n",
    "\n",
    "    for fu_name, fu in fus_status.items():\n",
    "        print(f\"  Checando FU {fu_name} (Opcode esperado={fu_type}, FU Opcode={fu['Opcode']}, Busy={fu['Busy']})\")\n",
    "\n",
    "        # 1. opcode não bate\n",
    "        if fu['Opcode'] != fu_type:\n",
    "            print(f\"    -> Falha: FU {fu_name} não suporta opcode {fu_type}\")\n",
    "            continue\n",
    "\n",
    "        # 2. FU já ocupada\n",
    "        if fu['Busy']:\n",
    "            print(f\"    -> Falha: FU {fu_name} ocupada (Busy=True)\")\n",
    "            continue\n",
    "\n",
    "        # 3. registrador destino já tem writer\n",
    "        if register_status[rd_i]['writer'] is not None:\n",
    "            print(f\"    -> Falha: registrador {rd_i} já tem writer {register_status[rd_i]['writer']}\")\n",
    "            continue\n",
    "\n",
    "        # Se passou em tudo, ocupa FU\n",
    "        print(f\"    -> Sucesso: Instr {id_i} emitida na FU {fu_name}\")\n",
    "        fu['Busy'] = True\n",
    "        fu['Op'] = id_i\n",
    "        fu['Fi'] = rd_i\n",
    "        fu['Fj'] = rs1_i\n",
    "        fu['Fk'] = rs2_i\n",
    "        fu['Qj'] = register_status[rs1_i]['writer'] if rs1_i is not None else None\n",
    "        fu['Qk'] = register_status[rs2_i]['writer'] if rs2_i is not None else None\n",
    "        fu['Rj'] = fu['Qj'] is None\n",
    "        fu['Rk'] = fu['Qk'] is None\n",
    "        register_status[rd_i]['writer'] = fu_name\n",
    "        instr['fu_name'] = fu_name\n",
    "        return True\n",
    "\n",
    "    print(f\"  -> Nenhuma FU disponível para emitir instrução {id_i}\")\n",
    "    return False\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "85afbda0",
   "metadata": {},
   "source": [
    "## Read Operands"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "62f5546a",
   "metadata": {},
   "source": [
    "verifica no `register_status` se alguma unidade funcional vai escrever nos operandos de leitura `rs1` e `rs2`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "id": "796bc1bd",
   "metadata": {},
   "outputs": [],
   "source": [
    "def read_operands(rs1_i, rs2_i, register_status):\n",
    "    ready_rs1 = (rs1_i is None) or (register_status[rs1_i]['writer'] is None)\n",
    "    ready_rs2 = (rs2_i is None) or (register_status[rs2_i]['writer'] is None)\n",
    "    return ready_rs1 and ready_rs2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "61eed7d7",
   "metadata": {},
   "source": [
    "## Complete Execution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "id": "db4c37fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def execute(fu, cycle, inst):\n",
    "    if fu['Cycles_left'] > 0:\n",
    "        fu['Cycles_left'] -= 1\n",
    "        print(f\"INFO: Instrução '{inst['inst']}' está executando. Ciclos restantes: {fu['Cycles_left']}.\")\n",
    "    if fu['Cycles_left'] == 0:\n",
    "        inst['execution_complete'] = cycle\n",
    "        fu['Cycles_left'] = fu['Cycles']\n",
    "        print(f\"OK: Instrução '{inst['inst']}' completou a execução.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "189a8269",
   "metadata": {},
   "source": [
    "## Write Results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a0574939",
   "metadata": {},
   "outputs": [],
   "source": [
    "# def write_results(fu, inst):\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "70bd7c83",
   "metadata": {},
   "source": [
    "## Scoreboard"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c5f896cf",
   "metadata": {},
   "source": [
    "### Montando a instrução novamente"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "id": "8d66fc1f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def any_fu_busy(fus):\n",
    "    for fu_name, fu in fus.items():\n",
    "        if fu['Busy']:\n",
    "            return True\n",
    "    return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "id": "7ecc8c66",
   "metadata": {},
   "outputs": [],
   "source": [
    "prog_file = \"tests/ex.s\"\n",
    "fus_file = \"tests/uf_config1.in\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "id": "f15ed37d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def has_pending_instructions(inst_status):\n",
    "    return any(inst['execution_complete'] is None for inst in inst_status)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "64473224",
   "metadata": {},
   "source": [
    "fld f1, 0(x1)\n",
    "fld f5, 0(x1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "id": "ddfa969b",
   "metadata": {},
   "outputs": [],
   "source": [
    "register_status = ini_register_status()\n",
    "instruction_status = init_instruction_status(prog_file)\n",
    "fus_status = init_fus_status(fus_file)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d448df2a",
   "metadata": {},
   "source": [
    "Debug"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "id": "723e14d7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Cycle 1 ---\n",
      "PC = 0\n",
      "\n",
      "[ISSUE] Tentando emitir instrução 0: fld f1, 0(x1)\n",
      "  Checando FU int1 (Opcode esperado=0, FU Opcode=0, Busy=False)\n",
      "    -> Sucesso: Instr 0 emitida na FU int1\n",
      "--> Instr 0 emitida\n",
      "\n",
      "--- Cycle 2 ---\n",
      "PC = 1\n",
      "--> Read operands OK para instr 0\n",
      "\n",
      "[ISSUE] Tentando emitir instrução 1: fld f5, 0(x1)\n",
      "  Checando FU int1 (Opcode esperado=0, FU Opcode=0, Busy=True)\n",
      "    -> Falha: FU int1 ocupada (Busy=True)\n",
      "  Checando FU int2 (Opcode esperado=0, FU Opcode=0, Busy=False)\n",
      "    -> Sucesso: Instr 1 emitida na FU int2\n",
      "--> Instr 1 emitida\n",
      "\n",
      "--- Cycle 3 ---\n",
      "PC = 2\n",
      "INFO: Instrução 'fld f1, 0(x1)' está executando. Ciclos restantes: 0.\n",
      "OK: Instrução 'fld f1, 0(x1)' completou a execução.\n",
      "--> Read operands OK para instr 1\n",
      "\n",
      "[ISSUE] Tentando emitir instrução 2: fdiv x3, x2, x5\n",
      "  Checando FU int1 (Opcode esperado=3, FU Opcode=0, Busy=True)\n",
      "    -> Falha: FU int1 não suporta opcode 3\n",
      "  Checando FU int2 (Opcode esperado=3, FU Opcode=0, Busy=True)\n",
      "    -> Falha: FU int2 não suporta opcode 3\n",
      "  Checando FU mult1 (Opcode esperado=3, FU Opcode=1, Busy=False)\n",
      "    -> Falha: FU mult1 não suporta opcode 3\n",
      "  Checando FU mult2 (Opcode esperado=3, FU Opcode=1, Busy=False)\n",
      "    -> Falha: FU mult2 não suporta opcode 3\n",
      "  Checando FU add1 (Opcode esperado=3, FU Opcode=2, Busy=False)\n",
      "    -> Falha: FU add1 não suporta opcode 3\n",
      "  Checando FU div1 (Opcode esperado=3, FU Opcode=3, Busy=False)\n",
      "    -> Sucesso: Instr 2 emitida na FU div1\n",
      "--> Instr 2 emitida\n",
      "\n",
      "--- Cycle 4 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fld f5, 0(x1)' está executando. Ciclos restantes: 0.\n",
      "OK: Instrução 'fld f5, 0(x1)' completou a execução.\n",
      "--> Read operands OK para instr 2\n",
      "\n",
      "--- Cycle 5 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 9.\n",
      "\n",
      "--- Cycle 6 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 8.\n",
      "\n",
      "--- Cycle 7 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 7.\n",
      "\n",
      "--- Cycle 8 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 6.\n",
      "\n",
      "--- Cycle 9 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 5.\n",
      "\n",
      "--- Cycle 10 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 4.\n",
      "\n",
      "--- Cycle 11 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 3.\n",
      "\n",
      "--- Cycle 12 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 2.\n",
      "\n",
      "--- Cycle 13 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 1.\n",
      "\n",
      "--- Cycle 14 ---\n",
      "PC = 3\n",
      "INFO: Instrução 'fdiv x3, x2, x5' está executando. Ciclos restantes: 0.\n",
      "OK: Instrução 'fdiv x3, x2, x5' completou a execução.\n"
     ]
    }
   ],
   "source": [
    "pc = 0\n",
    "cycle = 1\n",
    "while pc < len(instruction_status) or has_pending_instructions(instruction_status):\n",
    "    print(f\"\\n--- Cycle {cycle} ---\")\n",
    "    print(f\"PC = {pc}\")\n",
    "\n",
    "    # EXECUTE\n",
    "    for inst in instruction_status:\n",
    "        if inst['read_operands'] is not None and inst['read_operands'] < cycle and inst['execution_complete'] is None:\n",
    "            fu = fus_status[inst['fu_name']]\n",
    "            execute(fu, cycle, inst)\n",
    "\n",
    "    # 1. Read operands\n",
    "    for inst in instruction_status:\n",
    "        if inst['issue'] is not None and inst['read_operands'] is None:\n",
    "            rs1_i = inst['rs1']\n",
    "            rs2_i = inst['rs2']\n",
    "            if read_operands(rs1_i=rs1_i, rs2_i=rs2_i, register_status=register_status):\n",
    "                inst['read_operands'] = cycle\n",
    "                for fu_name, fu in fus_status.items():\n",
    "                    if fu['Op'] == inst['id']:\n",
    "                        fu['Rj'] = False\n",
    "                        fu['Rk'] = False\n",
    "                print(f\"--> Read operands OK para instr {inst['id']}\")\n",
    "\n",
    "    # 2. Issue\n",
    "    if pc < len(instruction_status):\n",
    "        next_instruction = instruction_status[pc]\n",
    "        if issue(next_instruction, fus_status, register_status):\n",
    "            next_instruction['issue'] = cycle\n",
    "            print(f\"--> Instr {next_instruction['id']} emitida\")\n",
    "            pc += 1\n",
    "        else:\n",
    "            print(f\"--> Instr {next_instruction['id']} NÃO pôde ser emitida\")\n",
    "            # print(issue(next_instruction, fus_status, register_status))\n",
    "\n",
    "    cycle += 1\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "id": "a06d04c5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# pc=0\n",
    "# cycle = 1\n",
    "# while pc < len(instruction_status) or has_pending_instructions(instruction_status):\n",
    "#     print(f\"--- Cycle {cycle} ---\")\n",
    "    \n",
    "#     # 1. Read operands (só acontece se a instrução já foi emitida em ciclos anteriores)\n",
    "#     for inst in instruction_status:\n",
    "#         if inst['issue'] is not None and inst['read_operands'] is None:\n",
    "#             rs1_i = inst['rs1']\n",
    "#             rs2_i = inst['rs2']\n",
    "#             if read_operands(rs1_i=rs1_i, rs2_i=rs2_i, register_status=register_status):\n",
    "#                 inst['read_operands'] = cycle\n",
    "#                 for fu_name, fu in fus_status.items():\n",
    "#                     if fu['Op'] == inst['id']:\n",
    "#                         fu['Rj'] = False\n",
    "#                         fu['Rk'] = False\n",
    "                \n",
    "    \n",
    "#     # 2. Issue (nova instrução pode ser emitida nesse ciclo)\n",
    "#     if pc < len(instruction_status):\n",
    "#         next_instruction = instruction_status[pc]\n",
    "#         if issue(next_instruction, fus_status, register_status):\n",
    "#             next_instruction['issue'] = cycle\n",
    "#             pc+=1\n",
    "#     # for inst in instruction_status:\n",
    "#     #     if inst['issue'] is None:\n",
    "#     #         print(inst)\n",
    "#     #         if issue(inst, fus_status, register_status):\n",
    "#     #             inst['issue'] = cycle\n",
    "#     #             print(f\"entrei no issue na int{inst}\") \n",
    "#     # pc+=1\n",
    "#     cycle += 1\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10b049d8",
   "metadata": {},
   "source": [
    "## Print Resultado"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "id": "71fdbd8b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "def formatar_tabela_scoreboard(instruction_status):\n",
    "    \"\"\"\n",
    "    Formata o resultado da simulação do scoreboard em uma tabela legível.\n",
    "\n",
    "    Args:\n",
    "        instruction_status (list): A lista final com o status de cada instrução.\n",
    "\n",
    "    Returns:\n",
    "        pandas.DataFrame: A tabela formatada com os resultados.\n",
    "    \"\"\"\n",
    "    # 1. Cria o DataFrame a partir da sua lista de resultados\n",
    "    df = pd.DataFrame(instruction_status)\n",
    "\n",
    "    # 2. Seleciona apenas as colunas que importam para a tabela final\n",
    "    tabela_final = df[['inst', 'issue', 'read_operands', 'execution_complete', 'write_result']]\n",
    "\n",
    "    # 3. Renomeia as colunas para o formato desejado\n",
    "    tabela_final = tabela_final.rename(columns={\n",
    "        'inst': 'Instruction/Cicle',\n",
    "        'issue': 'Issue',\n",
    "        'read_operands': 'Read',\n",
    "        'execution_complete': 'Execute', # Este é o ciclo em que a execução TERMINA\n",
    "        'write_result': 'Write'\n",
    "    })\n",
    "\n",
    "    # 4. Substitui valores 'None' ou 'NaN' por um traço para ficar mais limpo\n",
    "    tabela_final = tabela_final.fillna(\"-\")\n",
    "\n",
    "    return tabela_final"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "id": "bafa925c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  Instruction/Cicle  Issue  Read  Execute Write\n",
      "0     fld f1, 0(x1)      1     2        3     -\n",
      "1     fld f5, 0(x1)      2     3        4     -\n",
      "2   fdiv x3, x2, x5      3     4       14     -\n"
     ]
    }
   ],
   "source": [
    "tabela_de_resultados = formatar_tabela_scoreboard(instruction_status)\n",
    "print(tabela_de_resultados.to_string())"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ambiente",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
